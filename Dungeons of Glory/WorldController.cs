using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

public class WorldController : MonoBehaviour {

    public static WorldController Instance { get; protected set; }

    public Sprite[] floorImgs;

    Dictionary<Tile, GameObject> tileGameObjectMap;

    public World World { get; protected set; }

    public void Start() {
        if (Instance != null ) {
            Debug.LogError ( "There should never be two world controllers." );
        }
        Instance = this;

        // Instantiate grid
        World = new World();

        // Instantiate the dictionary that tracks which GameObject is rendering which Tile data.
        tileGameObjectMap = new Dictionary<Tile, GameObject> ();

        // Populate grid with tiles
        for (int y = 0; y < World.Height; y++) {
            for (int x = 0; x < World.Width; x++) {
                Tile tileData = World.GetTileAt(x, y);
                GameObject newTile = new GameObject();

                // Add tile/Gameobject pair to the dictionary
                tileGameObjectMap.Add ( tileData, newTile );

                newTile.name = "Tile [" + x + ", " + y + "]";
                newTile.transform.position = new Vector3 ( x, y, 0 );
                newTile.transform.localScale = new Vector3 ( tileData.TileSize, tileData.TileSize, 0 );
                newTile.transform.SetParent ( this.transform, true );

                // Set tile sprite
                SpriteRenderer tileSprite = newTile.AddComponent<SpriteRenderer>();
                // At this point, the map information should have been generated by now, so we can simply assign the tile sprites according to the tile type data
                // Sets the tile sprite based on the type of tile specified in tileData
                tileSprite.sprite = floorImgs[(int) tileData.Type];

                // Register OnTileTypeChanged callback
                tileData.AddTileTypeCallback ( OnTileTypeChanged );
            }
        }
    }

    public void Update() {
        if ( Input.GetKeyDown ( KeyCode.Space ) ) {
            World.RandomizeTiles ();
        }
    }

    void OnTileTypeChanged ( Tile _tileData ) {

        if (tileGameObjectMap.ContainsKey (_tileData) == false ) {
            Debug.LogError ( "tileGameObjectMap doesn't contain tileData -- did you forget to add the tile to the dictionary? Or maybe forget to unregister the callback?" );
            return;
        }

        GameObject _tile = tileGameObjectMap[_tileData];

        if (_tile == null ) {
            Debug.LogError ( "tileGameObjectMap's returned gameobject is null -- did you forget to add the tile to the dictionary? Or maybe forget to unregister the callback?" );
            return;
        }

        // If type index is outside of the floor image array
        if ( (int) _tileData.Type < 0 || (int) _tileData.Type > floorImgs.Length ) {
            Debug.LogError ( "OnTileTypeChanged - No floor image found for established floor type" );
        } else {
            _tile.GetComponent<SpriteRenderer> ().sprite = floorImgs[(int) _tileData.Type];
        }
    }

    public Tile GetTileAtWorldCoord ( Vector3 coord ) {
        // To find the tile at the mouse position (since the map has been centered to the world), we'll need to take the world size into account
        // We'll also need to take tile size into account as well, in case we ever want to change the tile size
        int x = Mathf.RoundToInt( coord.x );
        int y = Mathf.RoundToInt( coord.y );

        // Debug.Log ( "Coords: " + coord + " | Getting Tile [" + x + ", " + y + "]" );

        return this.World.GetTileAt ( x, y );
    }
}
